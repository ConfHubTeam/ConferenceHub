/**
 * Unified Notification Service
 * 
 * Following SOLID principles:
 * - Single Responsibility: Handles notification creation and dispatching
 * - Open/Closed: Extensible for new notification channels without modifying existing code
 * - Liskov Substitution: Can work with different notification providers
 * - Interface Segregation: Focused notification orchestration methods
 * - Dependency Inversion: Depends on abstractions (notification channels) not implementations
 * 
 * Implements DRY principle by centralizing notification logic and template generation
 */

const Notification = require("../models/notification");
const User = require("../models/users");
const Place = require("../models/places");
const Booking = require("../models/bookings");
const eskizSMSService = require("./eskizSMSService");

class UnifiedNotificationService {
  /**
   * Note: SMS message content is now generated by individual service classes
   * (e.g., bookingNotificationService.js) and passed directly to this service.
   * This follows single responsibility principle - each service manages its own message logic.
   */

  /**
   * Create and dispatch unified notification (in-app + SMS for booking types only)
   * @param {object} notificationData - Notification configuration
   * @returns {Promise<object>} Creation result
   */
  static async createNotification({
    userId,
    type,
    title,
    message,
    metadata = {},
    sendSMS = true
  }) {
    try {
      console.log(`üîî CREATING NOTIFICATION - User: ${userId}, Type: ${type}, SendSMS: ${sendSMS}`);
      console.log(`üìù Message: ${message}`);
      
      // Create in-app notification first (primary channel)
      const notification = await Notification.create({
        userId,
        type,
        title,
        message,
        metadata,
        isRead: false,
        isEmailSent: false,
        isSMSSent: false
      });

      console.log(`‚úÖ In-app notification created - ID: ${notification.id}, User: ${userId}, Type: ${type}`);

      // Only send SMS for booking-related notifications to reduce costs
      const isBookingNotification = type.startsWith('booking_');
      
      console.log(`üì± SMS Check - IsBooking: ${isBookingNotification}, SendSMS: ${sendSMS}, Type: ${type}`);
      
      if (sendSMS && isBookingNotification) {
        console.log(`üöÄ TRIGGERING ASYNC SMS - NotificationID: ${notification.id}, UserID: ${userId}`);
        // Don't await SMS to avoid blocking in-app notification
        this.sendSMSNotification(notification.id, userId, type, metadata)
          .catch(error => {
            console.error(`‚ùå SMS notification failed for notification ${notification.id}:`, error.message);
          });
      } else if (sendSMS && !isBookingNotification) {
        console.log(`‚è≠Ô∏è SKIPPING SMS - Not a booking notification (${type})`);
      } else {
        console.log(`‚è≠Ô∏è SKIPPING SMS - SendSMS disabled or not booking type`);
      }

      return {
        success: true,
        notification,
        message: "Notification created successfully"
      };
    } catch (error) {
      console.error("Failed to create notification:", error.message);
      throw new Error(`Notification creation failed: ${error.message}`);
    }
  }

  /**
   * Send SMS notification using in-app notification message (single source of truth)
   * @param {number} notificationId - Notification database ID
   * @param {number} userId - Target user ID
   * @param {string} type - Notification type
   * @param {object} metadata - Notification metadata
   * @returns {Promise<object>} SMS sending result
   */
  static async sendSMSNotification(notificationId, userId, type, metadata = {}) {
    try {
      console.log(`üì± SMS PROCESSING STARTED - NotificationID: ${notificationId}, UserID: ${userId}, Type: ${type}`);
      
      // Get user's phone number
      const user = await User.findByPk(userId, {
        attributes: ["id", "phoneNumber", "name"]
      });

      if (!user || !user.phoneNumber) {
        console.log(`‚ùå SMS SKIPPED - User ${userId} has no phone number`);
        return { success: false, reason: "No phone number" };
      }

      console.log(`üë§ User found - ID: ${user.id}, Name: ${user.name}, Phone: ${user.phoneNumber}`);

      // Get the in-app notification message to use as SMS text (single source of truth)
      const notification = await Notification.findByPk(notificationId, {
        attributes: ["message"]
      });

      if (!notification || !notification.message) {
        console.log(`‚ùå SMS FAILED - No notification message found for ID: ${notificationId}`);
        return { success: false, reason: "No notification message" };
      }

      const smsMessage = notification.message;
      console.log(`üìû SENDING SMS - User: ${userId} (${user.phoneNumber}), NotificationID: ${notificationId}`);
      console.log(`üìÑ SMS Message: "${smsMessage}"`);

      // Send SMS via Eskiz service
      const smsResult = await eskizSMSService.sendSMS(user.phoneNumber, smsMessage);

      console.log(`üì± SMS RESULT - Success: ${smsResult.success}, RequestID: ${smsResult.requestId}, Error: ${smsResult.error || 'None'}`);

      // Update notification record with SMS status
      await this.updateNotificationSMSStatus(notificationId, smsResult);

      if (smsResult.success) {
        console.log(`‚úÖ SMS COMPLETED SUCCESSFULLY - User: ${userId} (${user.phoneNumber}), RequestID: ${smsResult.requestId}`);
        return {
          success: true,
          requestId: smsResult.requestId,
          message: "SMS sent successfully"
        };
      } else {
        console.error(`‚ùå SMS FAILED - User: ${userId}, Error: ${smsResult.error}`);
        return {
          success: false,
          error: smsResult.error,
          reason: "SMS service error"
        };
      }
    } catch (error) {
      console.error(`üí• SMS EXCEPTION - User: ${userId}, NotificationID: ${notificationId}, Error: ${error.message}`);
      
      // Update notification with error status
      try {
        await this.updateNotificationSMSStatus(notificationId, {
          success: false,
          error: error.message
        });
      } catch (updateError) {
        console.error("Failed to update notification SMS error status:", updateError.message);
      }

      return {
        success: false,
        error: error.message,
        reason: "SMS processing error"
      };
    }
  }

  /**
   * Update notification record with SMS delivery status
   * @param {number} notificationId - Notification ID
   * @param {object} smsResult - SMS sending result
   * @returns {Promise<void>}
   */
  static async updateNotificationSMSStatus(notificationId, smsResult) {
    try {
      const updateData = {
        isSMSSent: smsResult.success
      };

      if (smsResult.success) {
        updateData.smsRequestId = smsResult.requestId;
        updateData.smsDeliveredAt = new Date();
        updateData.smsError = null;
      } else {
        updateData.smsError = smsResult.error || "SMS delivery failed";
        updateData.smsRequestId = null;
      }

      await Notification.update(updateData, {
        where: { id: notificationId }
      });
    } catch (error) {
      console.error(`Failed to update SMS status for notification ${notificationId}:`, error.message);
      throw error;
    }
  }

  /**
   * Create booking notification with SMS
   * @param {object} bookingData - Booking notification data
   * @returns {Promise<object>} Creation result
   */
  static async createBookingNotification({
    userId,
    type,
    title,
    message,
    bookingId,
    placeId,
    additionalMetadata = {}
  }) {
    const metadata = {
      bookingId,
      placeId,
      ...additionalMetadata
    };

    return await this.createNotification({
      userId,
      type,
      title,
      message,
      metadata,
      sendSMS: true
    });
  }

  /**
   * Create review notification (in-app only - no SMS to reduce costs)
   * @param {object} reviewData - Review notification data
   * @returns {Promise<object>} Creation result
   */
  static async createReviewNotification({
    userId,
    type,
    title,
    message,
    reviewId,
    placeId,
    additionalMetadata = {}
  }) {
    const metadata = {
      reviewId,
      placeId,
      ...additionalMetadata
    };

    return await this.createNotification({
      userId,
      type,
      title,
      message,
      metadata,
      sendSMS: false // Explicitly disable SMS for review notifications
    });
  }

  /**
   * Test SMS service connectivity
   * @returns {Promise<object>} Test result
   */
  static async testSMSService() {
    return await eskizSMSService.testConnection();
  }
}

module.exports = UnifiedNotificationService;
