/**
 * Unified Notification Service
 * 
 * Following SOLID principles:
 * - Single Responsibility: Handles notification creation and dispatching
 * - Open/Closed: Extensible for new notification channels without modifying existing code
 * - Liskov Substitution: Can work with different notification providers
 * - Interface Segregation: Focused notification orchestration methods
 * - Dependency Inversion: Depends on abstractions (notification channels) not implementations
 * 
 * Implements DRY principle by centralizing notification logic and template generation
 */

const { Notification, User, Place, Booking } = require("../models");
const eskizSMSService = require("./eskizSMSService");

class UnifiedNotificationService {
  /**
   * Note: SMS message content is now generated by individual service classes
   * (e.g., bookingNotificationService.js) and passed directly to this service.
   * This follows single responsibility principle - each service manages its own message logic.
   */

  /**
   * Create and dispatch unified notification (in-app + SMS for booking types only)
   * @param {object} notificationData - Notification configuration
   * @returns {Promise<object>} Creation result
   */
  static async createNotification({
    userId,
    type,
    title,
    message,
    metadata = {},
    sendSMS = true,
    smsMessage = null // New: pre-translated SMS message
  }) {
    try {
      // Create in-app notification first (primary channel)
      const notification = await Notification.create({
        userId,
        type,
        title,
        message,
        metadata,
        isRead: false,
        isEmailSent: false,
        isSMSSent: false
      });

      // Only send SMS for booking-related notifications to reduce costs
      const isBookingNotification = type.startsWith('booking_');
      
      if (sendSMS && isBookingNotification) {
        // Don't await SMS to avoid blocking in-app notification
        this.sendSMSNotification(notification.id, userId, type, metadata, smsMessage)
          .catch(error => {
            console.error(`‚ùå SMS notification failed for notification ${notification.id}:`, error.message);
          });
      }

      return {
        success: true,
        notification,
        message: "Notification created successfully"
      };
    } catch (error) {
      console.error("Failed to create notification:", error.message);
      throw new Error(`Notification creation failed: ${error.message}`);
    }
  }

  /**
   * Send SMS notification using in-app notification message (single source of truth)
   * @param {number} notificationId - Notification database ID
   * @param {number} userId - Target user ID
   * @param {string} type - Notification type
   * @param {object} metadata - Notification metadata
   * @returns {Promise<object>} SMS sending result
   */
  static async sendSMSNotification(notificationId, userId, type, metadata = {}, smsMessage = null) {
    try {
      // Get user's phone number
      const user = await User.findByPk(userId, {
        attributes: ["id", "phoneNumber", "name"]
      });

      if (!user || !user.phoneNumber) {
        return { success: false, reason: "No phone number" };
      }

      // Use pre-translated SMS message if provided, otherwise fall back to in-app notification message
      let finalSMSMessage = smsMessage;
      
      if (!finalSMSMessage) {
        // Get the in-app notification message to use as SMS text (fallback for legacy support)
        const notification = await Notification.findByPk(notificationId, {
          attributes: ["message"]
        });

        if (!notification || !notification.message) {
          return { success: false, reason: "No notification message" };
        }

        finalSMSMessage = notification.message;
      }

      // Send SMS via Eskiz service
      const smsResult = await eskizSMSService.sendSMS(user.phoneNumber, finalSMSMessage);

      // Update notification record with SMS status
      await this.updateNotificationSMSStatus(notificationId, smsResult);

      if (smsResult.success) {
        return {
          success: true,
          requestId: smsResult.requestId,
          message: "SMS sent successfully"
        };
      } else {
        console.error(`‚ùå SMS FAILED - User: ${userId}, Error: ${smsResult.error}`);
        return {
          success: false,
          error: smsResult.error,
          reason: "SMS service error"
        };
      }
    } catch (error) {
      console.error(`üí• SMS EXCEPTION - User: ${userId}, NotificationID: ${notificationId}, Error: ${error.message}`);
      
      // Update notification with error status
      try {
        await this.updateNotificationSMSStatus(notificationId, {
          success: false,
          error: error.message
        });
      } catch (updateError) {
        console.error("Failed to update notification SMS error status:", updateError.message);
      }

      return {
        success: false,
        error: error.message,
        reason: "SMS processing error"
      };
    }
  }

  /**
   * Update notification record with SMS delivery status
   * @param {number} notificationId - Notification ID
   * @param {object} smsResult - SMS sending result
   * @returns {Promise<void>}
   */
  static async updateNotificationSMSStatus(notificationId, smsResult) {
    try {
      const updateData = {
        isSMSSent: smsResult.success
      };

      if (smsResult.success) {
        updateData.smsRequestId = smsResult.requestId;
        updateData.smsDeliveredAt = new Date();
        updateData.smsError = null;
      } else {
        updateData.smsError = smsResult.error || "SMS delivery failed";
        updateData.smsRequestId = null;
      }

      await Notification.update(updateData, {
        where: { id: notificationId }
      });
    } catch (error) {
      console.error(`Failed to update SMS status for notification ${notificationId}:`, error.message);
      throw error;
    }
  }

  /**
   * Create booking notification with SMS
   * @param {object} bookingData - Booking notification data
   * @returns {Promise<object>} Creation result
   */
  static async createBookingNotification({
    userId,
    type,
    title, // Fallback title for legacy notifications
    message, // Fallback message for legacy notifications
    translationKey, // New: translation key for in-app notification (e.g., "booking_requested")
    translationVariables, // New: variables for translation interpolation
    smsMessage, // SMS message (always localized, different from in-app)
    bookingId,
    placeId,
    additionalMetadata = {}
  }) {
    const metadata = {
      bookingId,
      placeId,
      // Store translation data for in-app notifications
      translationKey,
      translationVariables,
      ...additionalMetadata
    };

    // Use fallback titles for database storage, frontend will translate dynamically
    const notificationTitle = translationKey ? `${translationKey}.title` : title;
    const notificationMessage = translationKey ? `${translationKey}.message` : message;

    return await this.createNotification({
      userId,
      type,
      title: notificationTitle,
      message: notificationMessage,
      metadata,
      sendSMS: true,
      smsMessage // Pass SMS message separately
    });
  }

  /**
   * Create review notification (in-app only - no SMS to reduce costs)
   * @param {object} reviewData - Review notification data
   * @returns {Promise<object>} Creation result
   */
  static async createReviewNotification({
    userId,
    type,
    title,
    message,
    reviewId,
    placeId,
    additionalMetadata = {}
  }) {
    const metadata = {
      reviewId,
      placeId,
      ...additionalMetadata
    };

    return await this.createNotification({
      userId,
      type,
      title,
      message,
      metadata,
      sendSMS: false // Explicitly disable SMS for review notifications
    });
  }

  /**
   * Test SMS service connectivity
   * @returns {Promise<object>} Test result
   */
  static async testSMSService() {
    return await eskizSMSService.testConnection();
  }
}

module.exports = UnifiedNotificationService;
